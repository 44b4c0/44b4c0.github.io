---
title: "SELinux vs მე"
date: 2024-11-20 15:26:00 +0400
categories: [CyberSecurity, Hacking]
tags: [Kernel]
---

## დარუთვის შემდეგ...

მოკლედ, წინა პოსტში ვთქვი, რომ ტელეფონი დავრუთე, მაგრამ გარკვეულ პრობლემებს მაინც წავაწყდი. რა თქმა უნდა, `Magisk`-დან `termux`-ს `root` წვდომა მივეცი, მაგრამ მან გარკვეული ქმედებების შესრულება მაინც ვერ შეძლო. კერძოდ, როდესაც `hardware`-თან დამჭირდა პირდაპირი კომუნიკაცია, კერნელმა დამბლოკა და `Access denied` მესიჯები ამომიყარა. მარტივი მაგალითებია:

```bash
sudo ifconfig wlan0 down
sudo macchanger -s wlan0
```

მოკლედ, ბევრი პრობლემა განვიხილე, მაგრამ საბოლოო ჯამში პასუხამდე მივედი.

## მისი უდიდებულესობა, `SELinux`

რა არის `SELinux`? მოკლედ რომ ვთქვა, `SELinux` ლინუქსის უსაფრთხოების არქიტექტურაა. ანუ მექანიზმი, რომელიც კერნელის უსაფრთხოებას უზრუნველყოფს.

1. ფაილები
2. პროცესები
3. ინტერფეისები
4. პორტები

ამ ყველაფერს იცავს `SELinux` მანიპულაციისაგან, მაგრამ ეს ყველაფერი ხელს მიშლის. იდეაში, ანდროიდები გათვლილი არაა პროფესიონალებზე. ისინი რაც შეიძლება მარტივად გამოსაყენებელნი უნდა იყონ და ლოგიკურია, რომ კერნელ დეველოპერებმა `SELinux` დააყენეს `Enforcing`-ზე.

#### რა სახის მოქმედების რეჟიმები არსებობს?

იდეაში, `SELinux`-ს სამი რეჟიმი აქვს:

1. Enforcing
2. Permissive
3. Disabled

ამ ყველაფერს, შესაბამისი რიცხვები აქვს:

1. Enforcing -> 1
2. Permissive -> 0
3. Disabled -> -1(თუ ზუსტად მახსოვს)

## მცდელობა #1

არის კონკრეტული ფაილი, რომელიც `SELinux` დაცვის სისტემის რეჟიმის შესახებ ინფორმაციას შეიცავს.

```
/sys/fs/selinux/enforce
```

იდეაში შესაძლებელია, რომ ამ ფაილის კონტენტი შეიცვალოს იმ შემთხვევაში თუ `TWRP`-დან უფლებები `rwxrwxrwx`-ზე, ანუ `777`-ზე დაყენდება.

ეს შეიძლება ასეთი ბრძანებით მოხდეს:

```bash
chmod 777 /sys/fs/selinux/enforce
```

ახლა კი შესაძლებელია, რომ ფაილით მანიპულაცია მოვახდინო:

```bash
echo 0 > /sys/fs/selinux/enforce
```

წესით, ამან `SELinux` უნდა გადაიყვანოს `Permissive`-ზე, `Enforcing`-დან.

```bash
getenforce
```

ამ ბრძანების `output` მაინც ეს არის:

```bash
Enforcing
```

ანუ გამოდის, რომ ამ მეთოდმა არ გაამართლა.

## მცდელობა #2

ისევ `root shell` მჭირდება. შემიძლია `Termux` გამოვიყენო ან `TWRP shell`-ით მივმართო კერნელს.

მოკლედ, ახლა ვცდილობ ოფიციალური ბრძანების მეშვეობით გამოვრთო `SELinux`:

```bash
setenforce 0
```

## მცდელობა #3

`/etc/config/selinux` ფაილის მოდიფიკაცია. საჭიროა ამ მნიშვნელობის შეცვლა.

```bash
SELINUX=Enforcing
```

მნიშვნელობა ასეთი უნდა იყოს:

```bash
SELINUX=Permissive
```

ამ მეთოდმაც არ გაამართლა. რჩება ერთი ვარიანტი. შემიძლია `boot.img` ფაილის გახსნა(Unpacking method) და მასში `enforce` ფაილის მოდიფიკაცია.

## რას მივიღებ ამით?

ამ ყველაფრით, ტელეფონის ყველა პერიფერიალზე და მის კერნელზე სრულ წვდომას მოვიპოვებ. ანუ, შემეძლება ყველაფრის გაკეთება, რაც კი მომინდება.

საუკეთესო ვარიანტი კი ამ შემთხვევაში `WAH(Wireless Attack Hub)`-ის აწყობა იქნება, ანუ სისტემის, რომელიც უსადენო კავშირის დროს შეტევების განხორციელებაში დამეხმარება. ეს შეიძლება იყოს რადიო, `Bluetooth`, `Wi-Fi` და ა.შ. დამატებითი პერიფერიალებით `RFID` კავშირის ჩაშლაც და მის წინააღმდეგ მოქმედებაც კი შემეძლება. რა თქმა უნდა, ამ ყველაფრისთვის მაქვს `ESP32` გამზადებული, მაგრამ მირჩევნია სმარტფონიდან შემეძლოს ამ ყველაფრის გაკეთება.

#### სოციალური ინჟინერიაც?

იმის გამო, რომ სმარტფონებს ე.წ. `Hotspot`-ის გაშვების შესაძლებლობა აქვთ, შემიძლია შევქმნა ყალბი ქსელები და მომხმარებლები შეცდომაში შევიყვანო. შემდეგ კი შემიძლია მატი ტრაფიკი ჩავიწერო `.pcap` ფაილში და შემდეგ მისი ანალიზი გავაკეთო. ეს იმიტომ, რომ როდესაც კლიენტი `Hotspot`-ზე შემოდის, მისი `Default Gateway` ავტომატურად `Hotspot`-იანი მოწყობილობა ხდება და `MiTM` შეტევის ცდაც კი არ მჭირდება. ანუ, არ მომიწევს `ARP cache`-ის დაბინძურება(Poisoning) და კლიენტი ყველა პაკეტსა(Network) თუ ფრეიმს(Data link) ჩემი მოწყობილობის გავლით გაისვრის. მე კი `libnpcap` ბიბლიოთეკის გამოყენებით დავწერ პროგრამას, რომელიც გამავალ ტრაფიკს ჩაიწერს `.pcap` ფაილში და შემდეგ `Wireshark`-ით გავაკეთებ მის ანალიზს. იდეაში მაქვს `.pcap` ფაილის პარსერი პითონში დაწერილი(`C++`-ში მქონდა თავიდან, მერე ის დავკარგე და `Python`-ში გადავწერე).
